6월 1일 월요일

## SOLID
- 로버트 마틴이 2000년대 초반에 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙
- 마이클 페이더스가 SOLID로 나누어 소개함
- 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 적용하는 원칙

### SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.

### OCP 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

### LSP 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

### ISP 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

### DIP 의존관계 역전 원칙
- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다.

</br>

### 소프트웨어의 가치
1. 👀가독성 커뮤니케이션
2. ✨단순성
3. 🌈유연성
    **유연성을 챙겨야 할 때**
    - 처음에는 단순하게
    - 기획 또는 정책의 변경이 발생
    - 이 기획 또는 정책의 변경의 원인이 무엇일까? 계속 발생가능한 일일까?
    - 확장성을 가지고 유연한 코드를 작성해야함
    
- 모든 문제를 해결하는 최고의 선택은 존재하지 않는다.
- 현재 상황에서 우선순위를 계산하여 최선의 선택을 하고 그를 위해서 기준을 세워둬야 한다.

</br>

## Generic 그리고 Protocol
- protocol을 타입으로 사용하는 것과 generic을 사용하여 특정 프로토콜을 채택한 타입만 받는 것의 차이는 뭘까

### protocol type
- protocol 채택한 타입은 `Existential Container`에 저장됨
- `value buffer`를 초과하지 않으면 스택에 저장
- `value buffer`를 초과하면 힙에 저장

- `pwt(protocol witness table)`를 이용해서 런타임에서 메서드를 찾아가는 과정이 생겨 다이나믹 메서드 디스패치 방식으로 성능이 떨어짐
- 값이 커진다면 힙에 저장되기 때문에 더더욱 성능이 떨어짐

### generic
- generic을 사용하면 `specialization`을 거치며 구체적인 타입을 인자로 전달받아 `Existential Container`를 사용할 필요가 없음
- 즉 다이나믹 디스패치나 힙에 저장되는 상황이 발생하지 않음

### 결론
- protocol을 채택한 모든 타입을 사용하는 것이라면 성능이 떨어지더라도 protocol을 타입으로 써야함
- protocol을 채택한 특정 타입만 사용하는 것이라면 generic을 사용하여 성능상 이점을 챙길 수 있음

**참고**
- [SOLID (객체 지향 설계)](https://ko.wikipedia.org/wiki/SOLID_(객체_지향_설계))
- [마법 같은 Swift 제네릭 이야기](https://techblog.zepeto.me/마법-같은-swift-제네릭-이야기-2c222ae2798)
- [Swift 성능 - 2. 프로토콜로 값타입 다형성 지원하기](https://velog.io/@yohanblessyou/Apple-Understanding-Swift-Performance-2.-프로토콜로-value-type-다형성-지원하기#-existential-container)

---
## 느낀점
- 코드가 같은 비슷한 동작을 하는 것 같아도 성능이 다를 수 있다.
- 하지만 코드를 무조건 성능에 따라 작성하는 것이 아닌 여러가지 이유를 생각하고 반영하여 작성하는 것이 좋다.

